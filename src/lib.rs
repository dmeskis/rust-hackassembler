use ::phf::phf_map;
use regex::Regex;
use std::collections::HashMap;
use std::error::Error;
use std::fs;
use std::fs::File;
use std::process;

static COMP_TO_BINARY: phf::Map<&'static str, &'static str> = phf_map! {
    // a=0
    "0" => "0101010",
    "1" => "0111111",
    "-1" => "0111010",
    "D" => "0001100",
    "A" => "0110000",
    "!D" => "0001101",
    "!A" => "0110001",
    "-D" => "0001111",
    "-A" => "0110011",
    "D+1" => "0011111",
    "A+1" => "0110111",
    "D-1" => "0001110",
    "A-1" => "0110010",
    "D+A" => "0000010",
    "D-A" => "0010011",
    "A-D" => "0000111",
    "D&A" => "0000000",
    "D|A" => "0010101",
    // a=1
    "M" => "1110000",
    "!M" => "1110001",
    "-M" => "1110011",
    "M+1" => "1110111",
    "M-1" => "1110010",
    "D+M" => "1000010",
    "D-M" => "1010011",
    "M-D" => "1000111",
    "D&M" => "1000000",
    "D|M" => "1010101",
};

static DEST_TO_BINARY: phf::Map<&'static str, &'static str> = phf_map! {
    "null" => "000",
    "M" => "001",
    "D" => "010",
    "MD" => "011",
    "A" => "100",
    "AM" => "101",
    "AD" => "110",
    "AMD" => "111",
};

static JUMP_TO_BINARY: phf::Map<&'static str, &'static str> = phf_map! {
    "null" => "000",
    "JGT" => "001",
    "JEQ" => "010",
    "JGE" => "011",
    "JLT" => "100",
    "JNE" => "101",
    "JLE" => "110",
    "JMP" => "111",
};
// use std::str::Lines;

// stack variables as parameters are copied and put on the stack because they are so cheap
// heap variables are not, which is why compilation errors will be raised
//
// Allocated memory needs to have one, and only one owner (exceptions but this is generally the
// rule)
//
// Borrow with &, memory ownership will be borrowed for the procedure call
//
// Strings are always on the heap
// &str is a pointer... to either stack or heap
//
// You can have multiple references, (read only pointers) to memory as long as the owner does not
// change before the references are used
//
// #[derive(Clone)] macro for adding clone trait to allow struct to be cloned
// e.g.
// #[derive(Debug, Clone)]
// struct MyStruct {
//   a: i32,
//   b: f64,
// }
//
// Prefer & if possible over Clone & Copy traits
//
// Rust Ownership & Borrowing
// Rust eliminates memory issues (null pointers, dangling pointers, data races)
// Eliminates the garbage collector
// Parallel processing is a breeze!
//
// Keep in mind stack vs heap when dealing with ownership & borrowing

// Define a collection of commands that can be parsed from file contents
// implement an iterator that can run iterate the commands
// 3 command types A_COMMAND, C_COMMAND, L_COMMAND (pseudo command)

pub struct Parser<'a> {
    commands: Vec<Command<'a>>,
    symbol_table: HashMap<String, usize>,
}

impl Parser<'_> {
    fn command_as_binary(&self, command: Command) -> Option<String> {
        match command {
            Command::A(val) => {
                if val.chars().nth(1).unwrap().is_numeric() {
                    let num = &val[1..].parse::<i32>().unwrap();
                    let num_as_binary = format!("0{:015b}", num);
                    Some(num_as_binary)
                } else {
                    // Handle case where A_COMMAND can be symbolic
                    let num = self.symbol_table[&val[1..]];
                    let num_as_binary = format!("0{:015b}", num);
                    Some(num_as_binary)
                }
            }
            Command::L(_val) => None,
            Command::C(_val) => {
                let bdest = Command::bdest(command.dest());
                let bcomp = Command::bcomp(command.comp());
                let bjump = Command::bjump(command.jump());
                let num_as_binary = format!("111{}{}{}", bcomp, bdest, bjump);
                Some(num_as_binary)
            }
        }
    }
}

// ACommand regex - @R?\d{1,}
// ACommand behind comment regex (/{2}.*)@R?\d{1,}
// c-instruction generated by grex
// ^(?:A?M(?:D=(?:(?:A\+1|D(?:[+\-][1A]|[&|]A)|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD])|=(?:(?:A\+1|D(?:[+\-][1A]|[&|]A)|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD]))|AD=(?:(?:A\+1|D(?:[+\-][1A]|[&|]A)|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD])|[AD]=(?:(?:A\+1|D(?:[+\-][1A]|[&|]A)|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD])|(?:A\+1|D[+\-][1A]|D[&|]A|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD])$

fn get_command_type(command: &str) -> Option<Command> {
    let a_command_regex = Regex::new("@.{1,}").unwrap();
    let l_command_regex = Regex::new("\\(.*\\)").unwrap();

    let is_l_command = l_command_regex.is_match(command);
    let is_a_command = a_command_regex.is_match(command);

    if is_l_command {
        Some(Command::L(command))
    } else if is_a_command {
        Some(Command::A(command))
    } else if !command.is_empty() {
        Some(Command::C(command))
    } else {
        None
    }
}

#[derive(Debug, Clone, Copy)]
enum Command<'a> {
    A(&'a str), // address
    C(&'a str), // compute
    L(&'a str), // pseudo
}

// dest=comp;jump
impl Command<'_> {
    fn dest(&self) -> Option<&str> {
        match self {
            Command::A(_val) => None,
            Command::L(_val) => None,
            Command::C(val) => {
                let idx = val.find('=');
                match idx {
                    Some(idx) => {
                        let comp = &val[0..idx];
                        Some(comp)
                    }
                    None => None,
                }
            }
        }
    }

    fn comp(&self) -> Option<&str> {
        match self {
            Command::A(_val) => None,
            Command::L(_val) => None,
            Command::C(val) => {
                let mut start_bytes = val.find('=').unwrap_or(0);
                if start_bytes > 0 {
                    start_bytes += 1;
                }

                let end_bytes = val.find(';').unwrap_or(val.len());
                Some(&val[start_bytes..end_bytes])
            }
        }
    }

    fn jump(&self) -> Option<&str> {
        match self {
            Command::A(_val) => None,
            Command::L(_val) => None,
            Command::C(val) => {
                let mut start_bytes = val.find(';').unwrap_or(0);
                if start_bytes == 0 {
                    return None;
                }
                start_bytes += 1;
                Some(&val[start_bytes..])
            }
        }
    }

    fn contains_variable_symbol(&self) -> bool {
        match self {
            Command::A(val) => val.chars().nth(1).unwrap().is_alphabetic(),
            Command::L(_val) => false,
            Command::C(_val) => false,
        }
    }

    // dest as string representation of binary
    fn bdest(mnemonic: Option<&str>) -> &str {
        DEST_TO_BINARY[mnemonic.unwrap_or(&"null")]
    }

    // jump as string representation of binary
    fn bjump(mnemonic: Option<&str>) -> &str {
        JUMP_TO_BINARY[mnemonic.unwrap_or(&"null")]
    }

    // comp as string representation of binary
    fn bcomp(mnemonic: Option<&str>) -> &str {
        COMP_TO_BINARY[mnemonic.unwrap()]
    }
}

pub fn parse_args(args: &[String]) -> Result<String, &str> {
    if args.len() < 2 {
        return Err("not enough arguments");
    }

    let filename = args[1].clone();

    Ok(filename)
}

pub fn run(args: &[String]) -> Result<(), Box<dyn Error>> {
    let filename = parse_args(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    let contents = fs::read_to_string(&filename).expect("no such file");

    // remove comments and whitespace, may still contain newlines
    let regex = Regex::new("\n{2,}|[^\\S\\r\\n]|//.*").unwrap();
    let contents = regex.replace_all(&contents, "").into_owned();

    let commands = contents
        .lines()
        .filter_map(|line| get_command_type(line))
        .collect::<Vec<Command>>();

    let mut symbol_table = HashMap::new();

    // Add predefined symbols
    symbol_table.insert("SP".to_string(), 0);
    symbol_table.insert("LCL".to_string(), 1);
    symbol_table.insert("ARG".to_string(), 2);
    symbol_table.insert("THIS".to_string(), 3);
    symbol_table.insert("THAT".to_string(), 4);
    for i in 0..15 {
        let key = format!("R{}", i);
        symbol_table.insert(key, i);
    }
    symbol_table.insert("SCREEN".to_string(), 16384);
    symbol_table.insert("KBD".to_string(), 24576);

    // Build symbol table
    // First pass - pseudo labels
    let mut count = 0;
    for command in commands.iter() {
        match command {
            Command::A(_val) => count += 1,
            Command::L(val) => {
                // handle label symbols
                let mut chars = val.chars();
                chars.next();
                chars.next_back();
                symbol_table.insert(chars.as_str().to_string(), count);
            }
            Command::C(_val) => count += 1,
        }
    }

    // Second pass - variable symbols
    let mut count = 16;
    for command in commands.iter() {
        if let Command::A(val) = command {
            if command.contains_variable_symbol() {
                let key = val[1..].to_string();
                if let std::collections::hash_map::Entry::Vacant(e) = symbol_table.entry(key) {
                    e.insert(count);
                    count += 1
                }
            }
        }
    }

    let parser = Parser {
        commands,
        symbol_table,
    };

    let mut result = vec![];
    for i in 0..parser.commands.len() {
        if let Some(binary) = parser.command_as_binary(parser.commands[i]) {
            result.push(binary);
        }
    }

    let filename_prefix = filename.split('.').collect::<Vec<&str>>()[0];
    let new_filename = format!("{}{}", filename_prefix, &".hack");

    let data = result.join("\n");

    File::create(&new_filename).unwrap();
    fs::write(new_filename, data).expect("Something went wrong writing your file");

    Ok(())
}
