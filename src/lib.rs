use regex::Regex;
use std::error::Error;
use std::fs;
use std::process;
// use std::str::Lines;

// stack variables as parameters are copied and put on the stack because they are so cheap
// heap variables are not, which is why compilation errors will be raised
//
// Allocated memory needs to have one, and only one owner (exceptions but this is generally the
// rule)
//
// Borrow with &, memory ownership will be borrowed for the procedure call
//
// Strings are always on the heap
// &str is a pointer... to either stack or heap
//
// You can have multiple references, (read only pointers) to memory as long as the owner does not
// change before the references are used
//
// #[derive(Clone)] macro for adding clone trait to allow struct to be cloned
// e.g.
// #[derive(Debug, Clone)]
// struct MyStruct {
//   a: i32,
//   b: f64,
// }
//
// Prefer & if possible over Clone & Copy traits
//
// Rust Ownership & Borrowing
// Rust eliminates memory issues (null pointers, dangling pointers, data races)
// Eliminates the garbage collector
// Parallel processing is a breeze!
//
// Keep in mind stack vs heap when dealing with ownership & borrowing

// Define a collection of commands that can be parsed from file contents
// implement an iterator that can run iterate the commands
// 3 command types A_COMMAND, C_COMMAND, L_COMMAND (pseudo command)

pub struct Parser<'a> {
    commands: Vec<Command<'a>>,
}

// ACommand regex - @R?\d{1,}
// ACommand behind comment regex (/{2}.*)@R?\d{1,}
// c-instruction generated by grex
// ^(?:A?M(?:D=(?:(?:A\+1|D(?:[+\-][1A]|[&|]A)|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD])|=(?:(?:A\+1|D(?:[+\-][1A]|[&|]A)|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD]))|AD=(?:(?:A\+1|D(?:[+\-][1A]|[&|]A)|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD])|[AD]=(?:(?:A\+1|D(?:[+\-][1A]|[&|]A)|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD])|(?:A\+1|D[+\-][1A]|D[&|]A|![AD]|[01])(?:;J(?:EQ|[GL][ET]|MP|NE))?|A?\-[1D](?:;J(?:EQ|[GL][ET]|MP|NE))?|[AD];J(?:EQ|[GL][ET]|MP|NE)|[AD])$

fn get_command_type(command: &str) -> Option<Command> {
    let a_command_regex = Regex::new("@.{1,}").unwrap();
    let l_command_regex = Regex::new("\\(.*\\)").unwrap();

    let is_l_command = l_command_regex.is_match(command);
    let is_a_command = a_command_regex.is_match(command);

    if is_l_command {
        Some(Command::LCommand(command))
    } else if is_a_command {
        Some(Command::ACommand(command))
    } else {
        if command.is_empty() {
            None
        } else {
            Some(Command::CCommand(command))
        }
    }
}

// impl Parser<'_> {}

enum Command<'a> {
    ACommand(&'a str), // address
    CCommand(&'a str), // compute
    LCommand(&'a str), // pseudo
}

impl Command<'_> {
    fn command_type(&self) -> &str {
        match self {
            Command::ACommand(_val) => "ACommand",
            Command::CCommand(_val) => "CCommand",
            Command::LCommand(_val) => "LCommand",
        }
    }

    fn symbol(&self) -> Option<&str> {
        match self {
            Command::ACommand(val) => Some(val),
            Command::LCommand(val) => Some(val),
            Command::CCommand(_val) => None,
        }
    }

    // dest=comp;jump
    fn dest(&self) -> Option<&str> {
        match self {
            Command::ACommand(_val) => None,
            Command::LCommand(_val) => None,
            Command::CCommand(val) => {
                let idx = val.find('=');
                match idx {
                    Some(idx) => {
                        let comp = &val[0..idx];
                        Some(comp)
                    }
                    None => None,
                }
            }
        }
    }

    fn comp(&self) -> Option<&str> {
        match self {
            Command::ACommand(_val) => None,
            Command::LCommand(_val) => None,
            Command::CCommand(val) => {
                let mut start_bytes = val.find('=').unwrap_or(0);
                if start_bytes > 0 {
                    start_bytes += 1;
                }

                let end_bytes = val.find(';').unwrap_or(val.len());
                Some(&val[start_bytes..end_bytes])
            }
        }
    }

    fn jump(&self) -> Option<&str> {
        match self {
            Command::ACommand(_val) => None,
            Command::LCommand(_val) => None,
            Command::CCommand(val) => {
                let mut start_bytes = val.find(';').unwrap_or(0);
                if start_bytes == 0 {
                    return None;
                }
                start_bytes += 1;
                Some(&val[start_bytes..])
            }
        }
    }
}

pub fn parse_args(args: &[String]) -> Result<String, &str> {
    if args.len() < 2 {
        return Err("not enough arguments");
    }

    let filename = args[1].clone();

    Ok(filename)
}

pub fn run(args: &[String]) -> Result<(), Box<dyn Error>> {
    let filename = parse_args(&args).unwrap_or_else(|err| {
        println!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    let contents = fs::read_to_string(filename).expect("no such file");

    // remove comments and whitespace, may still contain newlines
    let regex = Regex::new("\n{2,}|[^\\S\\r\\n]|//.*").unwrap();
    let contents = regex.replace_all(&contents, "").into_owned();

    let commands = contents
        .lines()
        .filter_map(|line| get_command_type(line))
        .collect::<Vec<Command>>();

    let parser = Parser { commands };

    for command in parser.commands {
        println!(" {:?}", command.dest());
        println!(" {:?}", command.comp());
        println!(" {:?}", command.jump());
    }

    Ok(())
}
